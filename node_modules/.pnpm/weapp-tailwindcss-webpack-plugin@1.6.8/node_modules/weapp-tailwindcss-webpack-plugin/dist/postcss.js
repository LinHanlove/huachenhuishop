'use strict';

function isObject(val) {
  return val !== null && typeof val === "object";
}
function _defu(baseObj, defaults, namespace = ".", merger) {
  if (!isObject(defaults)) {
    return _defu(baseObj, {}, namespace, merger);
  }
  const obj = Object.assign({}, defaults);
  for (const key in baseObj) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const val = baseObj[key];
    if (val === null || val === void 0) {
      continue;
    }
    if (merger && merger(obj, key, val, namespace)) {
      continue;
    }
    if (Array.isArray(val) && Array.isArray(obj[key])) {
      obj[key] = val.concat(obj[key]);
    } else if (isObject(val) && isObject(obj[key])) {
      obj[key] = _defu(val, obj[key], (namespace ? `${namespace}.` : "") + key.toString(), merger);
    } else {
      obj[key] = val;
    }
  }
  return obj;
}
function createDefu(merger) {
  return (...args) => args.reduce((p, c) => _defu(p, c, "", merger), {});
}
const defu = createDefu();

const noop = () => { };
const defaultOptions = {
    cssMatcher: (file) => /.+\.(?:wx|ac|jx|tt|q|c)ss$/.test(file),
    htmlMatcher: (file) => /.+\.(?:(?:(?:wx|ax|jx|ks|tt|q)ml)|swan)$/.test(file),
    jsMatcher: (file) => {
        if (file.includes('node_modules')) {
            return false;
        }
        return /.+\.[jt]sx?$/.test(file);
    },
    mainCssChunkMatcher: (file, appType) => {
        switch (appType) {
            case 'uni-app': {
                return /^common\/main/.test(file);
            }
            case 'mpx': {
                return /^app/.test(file);
            }
            case 'taro': {
                return /^app/.test(file);
            }
            case 'remax': {
                return /^app/.test(file);
            }
            case 'rax': {
                return /^bundle/.test(file);
            }
            case 'native': {
                return /^app/.test(file);
            }
            case 'kbone': {
                return /^(?:common\/)?miniprogram-app/.test(file);
            }
            default: {
                return true;
            }
        }
    },
    cssPreflight: {
        'box-sizing': 'border-box',
        'border-width': '0',
        'border-style': 'solid',
        'border-color': 'currentColor'
    },
    cssPreflightRange: 'view',
    customRuleCallback: noop,
    onLoad: noop,
    onStart: noop,
    onEnd: noop,
    onUpdate: noop
};
function getOptions(options) {
    return defu(options, defaultOptions);
}

const SYMBOL_TABLE = {
    BACKQUOTE: '`',
    TILDE: '~',
    EXCLAM: '!',
    AT: '@',
    NUMBERSIGN: '#',
    DOLLAR: '$',
    PERCENT: '%',
    CARET: '^',
    AMPERSAND: '&',
    ASTERISK: '*',
    PARENLEFT: '(',
    PARENRIGHT: ')',
    MINUS: '-',
    UNDERSCORE: '_',
    EQUAL: '=',
    PLUS: '+',
    BRACKETLEFT: '[',
    BRACELEFT: '{',
    BRACKETRIGHT: ']',
    BRACERIGHT: '}',
    SEMICOLON: ';',
    COLON: ':',
    QUOTE: "'",
    DOUBLEQUOTE: '"',
    BACKSLASH: '\\',
    BAR: '|',
    COMMA: ',',
    LESS: '<',
    PERIOD: '.',
    GREATER: '>',
    SLASH: '/',
    QUESTION: '?',
    SPACE: '',
    DOT: '.',
    HASH: '#'
};
const MappingChars2String = {
    [SYMBOL_TABLE.BRACKETLEFT]: '_l_',
    [SYMBOL_TABLE.BRACKETRIGHT]: '_r_',
    [SYMBOL_TABLE.PARENLEFT]: '_p_',
    [SYMBOL_TABLE.PARENRIGHT]: '_q_',
    [SYMBOL_TABLE.HASH]: '_h_',
    [SYMBOL_TABLE.EXCLAM]: '_i_',
    [SYMBOL_TABLE.SLASH]: '_div_',
    [SYMBOL_TABLE.DOT]: '_dot_',
    [SYMBOL_TABLE.COLON]: '_c_',
    [SYMBOL_TABLE.PERCENT]: '_pct_',
    [SYMBOL_TABLE.COMMA]: '_d_',
    [SYMBOL_TABLE.QUOTE]: '_y_'
};

function cssSelectorReplacer(selector) {
    return (selector
        .replace(/\\\[/g, MappingChars2String['['])
        .replace(/\\\]/g, MappingChars2String[']'])
        .replace(/\\\(/g, MappingChars2String['('])
        .replace(/\\\)/g, MappingChars2String[')'])
        .replace(/\\#/g, MappingChars2String['#'])
        .replace(/\\!/g, MappingChars2String['!'])
        .replace(/\\\//g, MappingChars2String['/'])
        .replace(/\\\./g, MappingChars2String['.'])
        .replace(/\\:/g, MappingChars2String[':'])
        .replace(/\\%/g, MappingChars2String['%'])
        .replace(/\\2c /g, MappingChars2String[','])
        .replace(/\\'/g, MappingChars2String["'"]));
}

function isSupportedRule(selector) {
    return !selector.includes(':hover');
}
const PATTERNS = [/:not\(template\)\s*~\s*:not\(template\)/.source, /:not\(\[hidden\]\)\s*~\s*:not\(\[hidden\]\)/.source].join('|');
const BROAD_MATCH_GLOBAL_REGEXP = new RegExp(PATTERNS, 'g');
function commonChunkPreflight(node, options) {
    node.selector = node.selector.replace(BROAD_MATCH_GLOBAL_REGEXP, 'view + view').replace(/\*/g, 'view');
    if (/::before/.test(node.selector) && /::after/.test(node.selector)) {
        const selectorParts = node.selector.split(',');
        if (!selectorParts.includes('view')) {
            selectorParts.push('view');
        }
        if (options.cssPreflightRange === 'all') {
            if (!selectorParts.includes(':not(not)')) {
                selectorParts.push(':not(not)');
            }
        }
        node.selector = selectorParts.join(',');
        if (typeof options.cssInjectPreflight === 'function') {
            node.append(...options.cssInjectPreflight());
        }
    }
}
function mpRulePreflight(node) {
    if (!isSupportedRule(node.selector)) {
        node.remove();
        return;
    }
    node.selector = cssSelectorReplacer(node.selector);
}

const createInjectPreflight = (options) => {
    const result = [];
    if (options && typeof options === 'object') {
        const entries = Object.entries(options);
        for (let i = 0; i < entries.length; i++) {
            const [prop, value] = entries[i];
            if (value !== false) {
                result.push({
                    prop,
                    value
                });
            }
        }
    }
    return () => {
        return result;
    };
};

const postcssPlugin = 'postcss-weapp-tailwindcss-rename';
const plugin = (options = {}) => {
    const { cssPreflight, cssPreflightRange, customRuleCallback } = getOptions(options);
    const cssInjectPreflight = createInjectPreflight(cssPreflight);
    return {
        postcssPlugin,
        Once(css) {
            css.walkRules((rule) => {
                commonChunkPreflight(rule, {
                    cssInjectPreflight,
                    cssPreflightRange,
                    isMainChunk: true,
                    customRuleCallback
                });
                mpRulePreflight(rule);
            });
        }
    };
};
plugin.postcss = true;

module.exports = plugin;
